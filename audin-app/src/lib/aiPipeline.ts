import { Email } from '@/types/email';
import { CalendarEvent } from '@/types/calendar';
import { EmailSummary, ProcessedDigest } from '@/types/digest';
import { 
  processEmail, 
  processCalendarEventForPodcast, 
  prepareEmailsForGPT, 
  sortEmailsByUrgency
} from './emailProcessor';
import { processEmailsToJSON, generatePodcastScript, generateAudio } from './openai';

export interface DigestResult {
  emailSummary: string;
  podcastScript: string;
  audioBuffer: ArrayBuffer;
  textDigest: string;
  processedEmails: number;
  processedEvents: number;
  structuredData: ProcessedDigest; // New: structured data for UI
}

// Main AI pipeline orchestrator
export async function generateDigest(
  emails: Email[], 
  calendarEvents: CalendarEvent[],
  voiceId?: string
): Promise<DigestResult> {
  try {
    console.log('ðŸš€ Starting enhanced AudIn digest generation...');
    
    // Step 1: Process raw data for AI input
    console.log('ðŸ“§ Processing emails for AI analysis...');
    const processedEmails = emails.map(processEmail);
    const emailContent = prepareEmailsForGPT(processedEmails);
    
    console.log('ðŸ¤– GPT Call 1: Converting emails to structured JSON...');
    
    // Step 2: GPT Call 1 - Convert emails to structured JSON with urgency scoring
    const emailSummaries = await processEmailsToJSON(emailContent);
    
    console.log(`ðŸ“Š Processed ${emailSummaries.length} emails with urgency scores`);
    
    // Step 3: Our code - Sort by urgency and process calendar
    const sortedEmails = sortEmailsByUrgency(emailSummaries);
    const calendarSummaries = calendarEvents.map(processCalendarEventForPodcast);
    
    // Step 4: Prepare calendar content for script generation
    const calendarContent = calendarSummaries.length > 0
      ? `TODAY'S CALENDAR EVENTS:\n${calendarSummaries.map(event => 
          `â€¢ ${event.time} - ${event.title} (${event.duration})${event.location ? ` at ${event.location}` : ''}`
        ).join('\n')}`
      : "No calendar events for today.";
    
    console.log('ðŸŽ™ï¸ GPT Call 2: Generating podcast script...');
    
    // Step 5: GPT Call 2 - Generate podcast script from structured data
    const podcastScript = await generatePodcastScript(sortedEmails, calendarContent);
    
    console.log('ðŸ”Š OpenAI TTS: Converting to audio...');
    
    // Step 6: Convert to audio
    const audioBuffer = await generateAudio(podcastScript, voiceId);
    
    // Step 7: Create structured data and text digest
    const structuredData: ProcessedDigest = {
      emails: sortedEmails,
      calendar: calendarSummaries,
      total_emails: sortedEmails.length,
      total_events: calendarSummaries.length
    };
    
    const textDigest = createEnhancedTextDigest(sortedEmails, calendarSummaries);
    const emailSummary = formatEmailsForDisplay(sortedEmails);
    
    console.log('âœ… Enhanced digest generation complete!');
    
    return {
      emailSummary,
      podcastScript,
      audioBuffer,
      textDigest,
      processedEmails: sortedEmails.length,
      processedEvents: calendarSummaries.length,
      structuredData
    };
    
  } catch (error) {
    console.error('âŒ Error in digest generation:', error);
    throw error;
  }
}

// Create enhanced text digest from structured data
function createEnhancedTextDigest(sortedEmails: EmailSummary[], calendarSummaries: any[]): string {
  const today = new Date().toLocaleDateString('en-US', { 
    weekday: 'long', 
    year: 'numeric', 
    month: 'long', 
    day: 'numeric' 
  });

  let digest = `# Your Daily Digest - ${today}\n\n## ðŸ“§ Emails (Sorted by Urgency)\n\n`;
  
  // Group emails by urgency level for better display
  const urgentEmails = sortedEmails.filter(e => e.urgency_score >= 7);
  const importantEmails = sortedEmails.filter(e => e.urgency_score >= 4 && e.urgency_score < 7);
  const generalEmails = sortedEmails.filter(e => e.urgency_score < 4);

  if (urgentEmails.length > 0) {
    digest += `### âš¡ Urgent (${urgentEmails.length})\n`;
    urgentEmails.forEach(email => {
      digest += `**${email.sender}**: ${email.summary} *(Urgency: ${email.urgency_score}/10)*\n\n`;
    });
  }

  if (importantEmails.length > 0) {
    digest += `### ðŸ“¬ Important (${importantEmails.length})\n`;
    importantEmails.forEach(email => {
      digest += `**${email.sender}**: ${email.summary} *(Urgency: ${email.urgency_score}/10)*\n\n`;
    });
  }

  if (generalEmails.length > 0) {
    digest += `### ðŸ§  General (${generalEmails.length})\n`;
    generalEmails.forEach(email => {
      digest += `**${email.sender}**: ${email.summary} *(Urgency: ${email.urgency_score}/10)*\n\n`;
    });
  }

  if (calendarSummaries.length > 0) {
    digest += `## ðŸ“… Today's Calendar\n\n`;
    calendarSummaries.forEach(event => {
      digest += `**${event.time}** - ${event.title} (${event.duration})`;
      if (event.location) digest += ` at ${event.location}`;
      digest += '\n\n';
    });
  }

  digest += `---\n\n*Generated by AudIn - Your Personal Inbox Radio*`;
  return digest;
}

// Format emails for display in dashboard
function formatEmailsForDisplay(sortedEmails: EmailSummary[]): string {
  return sortedEmails.map(email => 
    `${email.sender}: ${email.summary} (Urgency: ${email.urgency_score}/10)`
  ).join('\n');
}

// Helper function for demo mode
export async function generateDemoDigest(voiceId?: string): Promise<DigestResult> {
  // Import mock data dynamically to avoid bundling issues
  const { mockEmails } = await import('@/data/mockEmails');
  const { mockCalendarEvents } = await import('@/data/mockCalendar');
  
  return generateDigest(mockEmails, mockCalendarEvents, voiceId);
}
